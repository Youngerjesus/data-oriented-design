# 저장소와 검색 

## Intro 

- 데이터베이스가 하는 일은 데이터를 저장하고 요청했을 때 결과를 가져다주는 것. 
- 어플리케이션 개발자가 해야하는 일은 적절한 데이터엔진을 고르는 것.
  - 나의 어플리케이션에서 발생하는 작업 부하 (workload) 를 고려해야한다. 이를 위해서는 데이터베이스가 어떻게 동작하는지 이해할 필요가 있다. 
  - 특히 작업 부하에서는 트랜잭션 작업부하도 고려해야한다. 이건 여기에서 트랜잭션 처리와 분석 챕터에서 볼 것. 
- 여기서는 데이터 엔진 중 로그 계열 (Log-structured, B-Tree) 와 페이지 지향 (page-oriented) 계열 저장소 엔진을 검토한다. 

## 가장 간단한 데이터베이스 

- 데이터를 넣을 때 append-only 로 파일에 마지막에 추가하고 마지막에 저장된 데이터를 읽는 방법. (이게 가장 최신의 데이터니까.)
  - 이 방식은 쓰기에 굉장히 강하다. 
  - 대신에 파일이 계속 커지는 문제가 있고, 읽기에 부하가 있다. (그래서 색인을 추가해야한다.)

## 색인의 일반적인 개념 

- 색인은 원본 데이터 이외에 추가적인 메타데이터를 저장하는 것이다. 이걸 읽기에 이용해서 읽기 부하를 줄이는 것. 대신에 쓰기 부하가 늘어남.

## 해시색인 

- 여기서는 키-값 데이터를 색인하는데 이때 색인할 때 데이터의 위치를 저장해둔다. 
  - 하나의 파일에 데이터를 저장하는 경우 데이터의 위치는 바이트오프셋으로 저장하더라.
- 비트캐스크 (Bitcask) 나 리악 (Riak) 과 같은 메모리에 모든 해시 기반의 색인을 다 가지고 있는 데이터 엔진이 적합한 경우에는 **쓰기 부하가 많고, 키가 그렇게 많지 않은 경우에 적합하다.**
  - 메모리에서 쓰기가 발생하는게 디스크에서 쓰기가 발생하는 것보다 비용이 저렴해서.
  - 메모리에 모든 데이터를 다 올릴 수 있어서. 
  - 메모리에 다 올릴 수 없다면 해시 색잉의 비용은 좀 비싸다. 
    - 확장성 문제, 무작위 디스크 I/O 의 과다 발생 문제, 해시 충돌 문제 (I/O 랑 관련이 있을듯.)
    - 컴팩션하는 과정에서도 I/O 가 발생한다면 엄청 느려질 듯. 
- append-only 로그 처럼 파일에 항상 추가하는 방식을 이용한다면 결국 디스크 공간이 부족해진다. 이 경우에는 어떻게 해결할 수 있을까? 
  - 특정 크기에 도달하면 파일을 닫고 새 파일에 저장한다. 이런식으로 세그먼트 (segment) 식으로 나눈다.
  - 세그먼트끼리 compaction 작업을 해서 파일의 사이즈를 줄인다. 이를 통해 중복된 데이터를 줄이는게 핵심이다.
  - compaction 작업이나 여러 세그먼트를 merge 한 후 compaction 작업을 수행하는 경우에는 백그라운드 스레드로 처리하도록 해서 compaction 작업을 수행하는 중에도 읽기 작업을 계속해서 진행할 수 있도록 해야한다. 
  - 그리고 작업이 완료되면 새 세그먼트 파일로 교체하도록 하면 되고.

### 데이터베이스 엔진에서 중요한 요소. 
- 여기서 예시로 들고 있는 로그 계열의 해시 색인을 이용해 데이터베이스 엔진을 만들 떄는 다음과 같은 것들을 고려해야한다. **(데이터베이스에서 중요한 요소들.)**
  - 파일 혀식이 중요하다.
    - CSV ((Comma Separated Values) 와 같은 파일은 로그 계열의 데이터베이스 엔진에 적합한 파일 형식이 아님. 
    - CSV 파일은 일반 텍스트 파일. 텍스트 파일은 바이너리 파일보다 컴퓨터 입장에서 효율이 떨어진다.
      - 텍스트 파일과 같은 파일은 유니코드나 아스키 코드 형태로 데이터를 가공해서 저장하게 된다. 
      - 바이너리 파일은 그냥 바이너르 숫자 그대로 저장하게 됨. 그래서 바이트 길이를 기반으로 데이터를 읽고 쓰게된다.)
    - 텍스트 파일로 저장하는 경우에 여기서는 `, (comma) or \t, \n` 로 구별하게 되는데 이를 위해서는 데이터를 읽고 해석해야한다.  (결국 한번 가공을 했느냐 안했느냐의 차이네.)
    - 또 텍스트 파일의 경우 원본 그대로 저장하는게 아니라 가공해서 저장해야하니까.
    - 그래서 바이너리 형태로 저장할 수 있도록 문자열을 인코딩해서 저장할 수 있어야 더 빠를 것.
  - 레코드 삭제 
    - 키와 관련된 값을 삭제하려면 이를 알 수 있는 특수한 삭제 레코드 (때로는 툼스톤 (tombstone)) 이라는 데이터를 추가해야한다. 
    - 세그먼트가 병합할 때 이 툼스톤을 만나면 삭제 이전의 키 값은 무시하게 된다. 
  - 고장 (crash) 복구 
    - 데이터베이스가 재시작하면 인메모리 해시 맵은 손상된다. 
    - 이 경우 원칙적으로는 처음 세그먼트부터 다시 읽으면서 각 키에 대한 최신 오프셋을 확인하면서 인메모리 해시맵을 만들 수 있다. 
    - 하지만 세그먼트의 크기가 크다면 이런 복구하는 과정에서 드는 비용도 오래 걸릴 수 있다. 
    - 이를 빠르게 로딩하기 위해서는 디스크에 스냅샷과 같은 데이터가 있어야한다.
  - 부분적으로 레코드 쓰기 
    - 데이터베이스에서는 레코드에 쓰느 도중에 죽을 수 있다. 이때 데이터를 넣다가 죽었다 (= 완성된 데이터를 넣지 않았다.) 는 걸 알 수 있도록 손상된 부분을 탐지할 수 있어야한다. 
    - 이를 위해서는 체크섬이 있어야한다. 
  - 동시성 제어 
    - 쓰기를 엄격하게 제어하는 기본 원칙은 하나의 쓰레드만 허용하는 방식이다. 데이터 파일 세그먼트가 append-only 이거나 불변이라면 다중 스레드를 통해서 읽는 건 가능하게 할 수 있다.
  
### append only 로그 파일 vs 무작위 쓰기 로그 파일 

- 무작위 쓰기 로그 파일이라는 뜻은 새로운 값을 이미 쓰여진 장소에 가서 갱신하는 방법을 말하는 것이다. 이 둘을 비교해보자.  
  - append-only 는 순차적 쓰기로 자기 회전 하드 디스크에서 특히 강하다. 그리고 일부 확장된 순차 쓰기는 SSD 에서도 강하다. 이는 BTree 와 LSM 트리 비교에서 자세하게 다뤄보겠다. 
  - append-only 는 데이터베이스가 crash 날 때 걱정할 필요도 없다. 이전 값이 그대로 보장되면서 거기에 새 값을 추가하는 형태이기 때문에. 


## SS테이블과 LSM 트리 

### SS테이블 

- SS 테이블은 로그 계열의 저장소에서 데이터를 각 키 기반으로 정렬된 구조를 말한다. 
  - 이렇게 말하면 순차적 쓰기가 안되니까 안좋은거 아니냐고 물을 수 있다.
  - 다만 이 방식은 순차적 쓰기는 안되지만 레드 블렉 트리나 AVL 트리와 같은 balanced binary search tree 에 데이터를 넣는다면 그렇게 큰 부하가 아님. 
- SS 테이블의 장점 
  - compaction and merge 과정에서 merge sort 와 같은 방식으로 진행이 가능하다. 그래서 파일을 합치는 비용이 쌈.
  - 모든 키를 색인할 필요가 없음. 정렬되어 있으므로 희소 색인 (sparse index) 구조로 가도 됨.
    - 희소라는 뜻은 많은 범위에서 일부만 있다는 뜻이다.
  - 희소 색인을 바탕으로 특정지점부터 읽기를 시작할 수 있음.  
  - 희소 색인의 간격을 바탕으로 데이터 블록을 지정할 수 있고 이 부분은 디스크에 쓰기 전 압축할 수 있다. 

#### SS 테이블 색인 구조 (희소 색인)
````text
Key     Byte offset 
handmock    100491
handbag     102134
handsome    104667
hangout     106812
````

- SS 테이블의 읽기 과정
    - 가장 최신 세그먼트 SS 테이블을 읽는다. 여기에 데이터가 없으면 그 다음 것 이런식으로 진행한다.
    - (일정 시간이 지나면 SS 테이블은 디스크에 반영하기 떄문에, 그리고 백그라운드에서 컴팩션 과정을 수행한다.)
- SS 테이블 지적 
  - 다른 세그먼트에 동일한 입력키가 있다면 누가 최신인가? append-only 로그 계열은 가장 마지막에 들어온 요소가 최신이라는 걸 알 수 있음. 이것도 마지막에 만든 세그먼트가 최신 데이터임.
  - 디스크에 반영하기 전에 데이터베이스가 죽으면 가장 최신의 멤테이블 (= 최신 세그먼트 SS테이블) 은 날라간다. 이를 방지하기 위해서 복구할 수 있도록 append-only 로그 테이블을 기록해놔야한다. 

### SS테이블에서 LSM 트리 만들기 

- SS테이블 구조로 LSM 트리에 사용되었다 뭐 이런 뜻인듯. 
- LSM 트리의 기본 개념도 SS 테이블의 병합을 백그라운드에서 하는 것. 이 개념은 파일의 크기가 메모리보다 크더라도 효율적이다. 일부만 불러와서 병합하는게 가능하니까. 
- 그리고 Range 쿼리에 대응하는 것도 효율적. 쓰기도 순차적으로 쓰는거니까 효율적이다. 
  - 정렬된 블록을 디스크에 넣는 것이니.
  - 멤테이블이 임계치를 넘어가면 디스크에 쓴다.
  - 항상 순차적으로 세그먼트를 기록하기 떄문에 순차적 쓰기가 가능한거임. 

### SS테이블 성능 최적화

- 볼륨 필터 (bloom filter) 를 추가해야한다. 
  - 데이터가 없는 경우에는 가장 오래된 세그먼트를 찾아봐야하므로. 
  - 볼륨 필터는 키가 데이터베이스에 존재하지 않음을 알려준다. 
- SS 테이블은 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략이 있다.
  - size-tired 와 leveled compaction 둘 있음. 
  - size-tired 는 최신이고 좀 더 작은 SS테이블 병합을 오래되었고 큰 SS테이블에 연이어서 병합한다.
  - leveled compaction 은 키 범위를 더 작은 SS 테이블로 나누고 오래된 데이터는 개별 레벨로 이동시킨다. 점진적으로 병합을 한다. 
  - 각 전략은 이 문서를 참고
    - https://www.datastax.com/ko/blog/when-use-leveled-compaction

## B-Tree

- (내가 필요한 데이터, 페이지가 메모리에 없다면 디스크에서 가지고와야 할텐데 이를 어떻게 알고 가지고 오지?. 페이지 참조와 디스크 저장간의 관계를 알고싶다.)
- (페이지 참조는 포인터와 비슷하고 이건 디스크를 가리킨다.)
- B-Tree 와 SS 테이블의 공통점은 각 키가 정렬된 상태로 저장되어 있다는 점만 같다. 설계 철학은 다름. 
  - 다른점은 SS 테이블은 순차적 쓰기가 가능하다. 세그먼트를 순차적으로 저장하니까. 
  - 근데 B-Tree 는 테이블의 크기를 고정된 크기로 나뉜다. 일반적으로 메모리의 페이지 크기 (= 4KB) 와 같고 블록의 크기와도 같다.
  - 그리고 각 블록은 다른 페이지들을 참조할 수 있는 페이지 참조가 있다. 
  - B-Tree 는 갱신할 때 페이지에 덮어쓰는 반면에 SS 테이블은 계속해서 추가하고 병합한다. 

#### B-Tree 페이지 구성 

```text
# user_id = 251 을 검색한다고 가정해보자. 

# root page 에서 200 - 300 사이에 있는 reference 를 가지고 하위 페이지를 참조한다. 
... ref | 100 | ref | 200 | ref | 300 | ref 400 

# 200-300 하위 페이지. 250-270 에 있는 reference 를 가지고 또 하위 페이지를 참조한다.  

... | 210 | ref | 230 | ref | 250 | ref | 270 | ref | 290  


# 250-270 하위 페이지. 여기서는 리프노드이므로 실제 값을 가져올 수 있다. (아마 여기서 실제 도큐먼트 블록와 연결된 주소를 가지고 있을 것.)  

...| 250 | val | 251 | val | 252 | val ...
```

- B-Tree 는 페이지 참조를 루트에서 시작한다. 
- 한 페이지에서 다른 페이지로 참조할 수 있는 수를 분기 계수 (branching factor) 이라고 부른다. 
- B-tree 의 갱신, 추가는 이렇다.
  - 갱신할려는 페이지를 루트부터 찾아서 갱신하고 디스크에 반영한다.
  - 추가할 때 페이지가 가득 찼다면 쪼개서 새로운 두 페이지를 만들고 부모에서 두 새 페이지를 참조할 수 있는 페이지 참조글 갱신한다. 
  - (이 방법은 분산 시스템에서 B-Tree 구조에서 업데이트가 성공해야 하는 부분이 많아서 잘 안쓰는 이유 중 하나. 트랜잭션의 비용이 큼.)
- 분기 계수가 500인 4KB 페이지의 경우 4단계 까지 찾는다고 할 때 저장되는 데이터의 양은 256TB 이다. 

### 신뢰할 수 있는 B-Tree 만들기

- B-Tree 에 삽입할 때 페이지 하나를 분할하고 상위 페이지에서 이 참조들을 업데이트 해줘야한다. 
- 근데 이 경우에서 장애가 나면 고아 페이지 (orphan page) 가 발생할 수 있다. 
- 그래서 B-Tree 에 데이터를 넣기 전 WAL (write-ahead log) 에 추가해야한다. 이를 redo-log 라고 부르기도 한다. 
  - 커밋이 되었지만 반영에 실패한 경우에는 redo 연산을 하고 커밋이 없다면 undo 연산을 한 후 다시 redo 하면 복원됨.

### B-Tree 최적화 

- 페이지 덮어쓰기와 데이터베이스에서 크래쉬가 날 경우게 복구를 위해서 쓰기 시 복사 (copy-on-write schema) 기법을 쓴다.
  - 페이지에서 업데이틀 될 때 기존 것 그대로 두고 복사해서 새 페이지를 만드는 그런 기법을 쓴다.  
  - Repeatable Read, Snapshot 과 같은 격리를 위해서 이 기법이 이용된다. 그래서 다중 버전 문서가 있을 수 있음. (MVCC)
  - 고장 복구를 위해서도 이 기법이 유용한듯. 실패하더라도 기존 것을 건드리지 않았으니. 
- 일반적으로 B-Tree 의 페이지는 디스크에 순차적으로 저장되지 않을 수 있다. (순차적으로 기록하려고 하지만 데이터의 크기가 커지면 그렇게 되지는 않는다는 듯.)
  - 다만 LSM 트리는 세그먼트가 병합되는 과정에서 큰 세그먼트를 한 번에 쓰기 떄문에 디스크에서 순차쓰기가 가능함.
  - (이래서 Range 쿼리는 LSM 트리가 더 강함.)
- 리프 페이지에 포인터를 추가해서 리프 페이지끼리는 다음, 이전 리프 페이지를 상위 페이지에게 물어보지 않고 이동이 가능함. 

### B-Tree 와 LSM 트리의 비교

- B-Tree 는 읽기에 강한 반면 LSM 트리는 쓰기에 더 강하다. 
  - LSM 트리가 비교적 읽기에 약한 이유는 병합된 모든 SS 테이블을 다 봐야할 수도 있기 때문에. 
- 벤치마크는 세부사항에 민감하기 떄문에 실제로 비교할 땐 해봐야한다

### LSM 트리의 장점

- B-Tree 보다 쓰기에 강하다. 
  - B-Tree 는 WAL 에 한번, 페이지에 한번 또 페이지 전체를 복사해야한다는 점이 있다. 
- LSM 트리도 컴팩션과 병합 과정 떄문에 쓰기를 여러번 해야한다. 근데 B-Tree 보다는 괜찮다는 입장. 
  - 이렇게 하나의 데이터베이스 쓰기가 여러번 디스크에 써지는 것을 쓰기 증폭 (write amplification) 이라고 부른다. 
  - (SSD 의 경우는 수명이 다할 떄까지 블록에 덮어쓰는 횟수가 제한되어 있으므로 이 쓰기 증폭이 중요한 관심사라고 한다.) 
  - 쓰기가 B-Tree 보다 더 낫다는 이유는 B-Tree 는 여러 페이지가 갱신될 수 있기 떄문에. 대신에 LSM 트리는 순차적인 처리를 할 수 있어서 특히 하드 디스크에서 B-Tree 보다는 강할 것이라는 입장. 
  - 하드디스크 뿐 아니라 SSD 에서도 강하다고 하는데 LSM 의 SS 테이블 구조는 파편화 현상이 B-Tree 보다 적고 낮은 쓰기 증폭 떄문에. 
  - (SDD 는 그리고 임의 쓰기도 순차 쓰기로 변환시키는 로그 구조화 알고리즘을 쓰기 때문에 임의 쓰기와 순차 쓰기가 그렇게 큰 요소는 아니라고 함.)
- 그리고 LSM 트리는 압축률이 더 좋다. 

### LSM 트리의 단점
 
- 읽기 성능에서 밀린다. 
  - 왜냐하면 읽기를 위해서 LSM 트리는 컴팩션 머지 과정을 기다려야 하는 경우가 있을 수 있기 때문에. 
  - 그래서 상위 응답시간을 보면 떄떄로 긴 경우가 있다는 듯. 다만 B-Tree 는 읽기에 균일하게 동작하는 편.
- 쓰기가 강하긴 하지만 컴팩션 사이즈가 더 클수록 더 많은 디스크 대역폭을 요구한다는 점. 
  - 그래서 컴팩션이 쓰기 유입 속도를 따라 잡지 못하면 계속해서 작은 SSTable 이 쌓이고 이를 통해 읽기가 계속 느려질 수 있다. 즉 모니터링을 해야한다. 
- (B-Tree 의 잠금은 키에 거는 것이 아니라 트리에 건다. 그래서 좀 더 성능상으로 좋음.)
