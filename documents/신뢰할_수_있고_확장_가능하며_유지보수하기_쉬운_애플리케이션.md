# 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

## Intro 

- 오늘날의 어플리케이션은 계산 중심 (compute-intensive) 가 아니라 데이터 중심 (data-intensive) 이다. 

  - 여기서 중요한건 CPU 성능이 아니라 데이터의 양, 데이터의 복잡도, 데이터의 변화속도가 중요하다. 
  - **이거에 맞는 적합한 시스템을 쓰는게 중요하다.**

- 오늘날 데이터 중심 어플리케이션에서 사용하고 있는 구성 요소는 다음과 같다. 

  - 어플리케이션에서 필요한 데이터를 저장하고 다시 찾을 수 있는 데이터베이스.
  - 읽기 속도 향상을 위한 캐시
  - 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있는 검색 색인 (search index)
  - 비동기 처리를 위해 다른 프로세스로 메시지를 보내는 스트림 처리 (stream processing.)
  - 주기적으로 대량의 누적된 데이터를 처리하는 일괄 처리 (batch processing)

- 여기서는 신뢰할 수 있고 확장 가능하며 유지보수 하기 쉬운 어플리켕시션을 만들도록 하는 기초적인 의미를 알아보도록 하한다.

## 소프트웨어 시스템에서 중요한 세 가지 구성요소 

- **신뢰성 (Reliability)**
  - 하드웨어나, 소프트웨어, 인적 오류에 대한 결함이 발생하더라도 시스템이 장애가 나지 않고 지속적으로 올바르게 동작할 수 있도록 하는 것.
  - **하드웨어 장애, 소프트웨어 장애, 인적 오류 이걸 키워드로 기억하자.**
- **확장성 (Scalability)**
  - 처리하는 데이터가 점점 늘어나더라도 그 부하를 견딜 수 있는 능력.
  - **부하 매개변수와 목표 성능 지표, 부하 대응 방식 를 기억해야한다.**
- **유지보수성 (Maintainability)**
  - 시간이 지나더라도 다양한 사람들이 현재 시스템에서 작업할 수 있는 능력. (기존의 작업을 보완하고, 새로운 작업을 추가하기 쉬운 능력.)
  - **운용성, 발전성, 단순성 이것만 기억하자.**

## 신뢰성 

- 예상된 성능에 대해서 확실히 처리하는 것. 
- 예상치 못한 사용에 대해서 문제가 생기더라도 잘 작동하는 것. (즉 무언가 잘못되더라도 계쏙해서 잘 작동할 수 있는 것.)
- 허가되지 않은 작업은 막는 것.  
- 신뢰성이 있다는 건 fault-tolerance 가 있다, resilient 가 있다 라고 말하기도 한다. 
- 결함 (fault) 와 장애 (failure) 를 오해하지 말자. 장애는 시스템이 멈춘 것을 말한다.

### 결함 유형: 하드웨어 장애

- 하드디스크가 고장나로 램에 결함이 생기고, 네트워크 케이블이 뽑히는 것과 같은 일이 생기는 것. 
- **일반적으로 하드디스크의 장애는 꽤 있는 편. 그래서 이런 장애를 견디기 위해서 RAID 와 같은 하드웨억 구성 요소에 중복 (redundancy) 를 추가하는 방법으로 해걸한다.**
  - **단일 장비의 신뢰성을 높이기 보다는 장비를 더 늘리는 편으로 간다. 이 경우에도 장비가 더 늘어나니 더 결함이 많아지는데 이런 문제를 견디기 위해서 장비의 유연성 (flexibility) 와 탄력성 (resilient) 가 중요시되는 추세.**
  - AWS 가 이런식으로 인스턴스를 운영한다. 
  - 이런 방식의 장점은 downtime 이 없다는 것.

### 결함 유형: 소프트웨어 장애

- 하드웨어의 결함은 독립적인 경향이 강하다면 (하나의 하드디스크 장애가 다른 하드디스크의 장애를 유도하지는 않는다.) 소프트웨어의 결함은 상관관계가 있을 수 있다. 
- 잘못된 입력이 들어오면 죽는 버그 (예전 리눅스에 이런 버그가 있었다.)
- 시스템 자원을 과도하게 점유하는 프로세스
- 시스템의 속도가 느려지는 경우 
- 한 요소의 결함이 다른 요소의 문제를 일으키는 경우. 
- 이런 문제를 해결하기 위해선 빈틈없는 테스트, 모니터링, 프로세스 격리, 죽은 프로세스 재시작 등과 같은 작업을 해야한다. 

### 결함 유형: 인적 오류 

- 대부분의 오류는 사람의 실수가 크게 관련한다. 그래서 사람의 실수가 날 수 있는 부분을 예상하고 실수가 일어나지 않게끔 방향을 잘 잡아주는게 중요하다. 
- **예를 들면 잘 설계된 추상화 인터페이스를 제공해주는 것.** 
  - 그런데 너무 제한적인 인터페이스를 설계하면 제한된 인터페이스를 피해서 작업하다 보니, 문제가 생길 수 있다.
  - (옳은 길을 갈 수 있도록 방향성을 제시해주는 것. 근데 너무 제한되게 제공해줄려고 하면 안됨.)
- 사람이 실수 할 수 있는 부분을 예측하고 이를 분리해야한다.
  - 실제 데이터를 가지고 있지만 실제 환경은 아닌 비프로덕션 환경인 샌드박스 (sandbox) 를 제공해줘야한다.
  - 자동화 할 수 있는건 자동화해야함.
- 철저하게 테스트하라.
  - **정상적인 케이스부터 엣지 케이스까지. (엣지 케이스에 주목해서 테스트 해야한다.)**
- 장애가 발생하면 빠르게 롤백할 수 있는 환경을 만들어라. 
- 새로운 코드는 천천히 배포해서 기능의 동작을 보도록 해라.
  - **비프로덕션 환경이 없는 상황에서는 카나리 배포 같은 걸 해야곘네.** 
- 성능 지표와 오류를 볼 수 있는 지표를 수직하고 모니터링 할 수 있도록 해라. 
- 조직 교육과 실습을 진행하라. 

## 확장성 

- 시스템이 현재는 안정가능하더라도 미래에 부하가 커져도 안정할 수는 없다. 이에 대비해야한다.
- **확장성을 고려한다는 건 예상되는 부하를 견디기 위해서 자원을 얼마나 투입해야 하는 지 를 계산할 수 있어야하고, 대처 방안을 알고 있어야한다.**
  - 자원만 더 투입하면 되는지, 아니면 대처가 있는지 고민.
  - **부하 매개변수를 고려해서 미래의 부하를 생각해보고 이것에 대응가능한지 고민해보는 것.**

### 부하 기술하기

- 부하를 기술해야지 미래의 부하에 대해서도 논할 수 있다.
- 이런 부하를 다루는 매개변수를 부하 매개변수 (load parameter) 라고 부른다. 
  - 부하 배개변수로는 초당 웹 요청 게수, 데이터베이스 읽기 쓰기 비율, 캐시 적중률, 채팅 서버라면 대화방의 수, 데이터 양, 데이터 사이즈, 등이 있다. 
  - 이는 시스템 설계에 따라 달라진다.
- 여기서는 부하를 기술할 때 트위터 서비스를 기반으로 설명한다.
  - 트위터의 주요 기능은 트윗 작성과 홈 타임라인을 보는 기능이다. 
  - 홈 타임라인을 보는 기능은 내가 팔로우하고 있는 트윗을 보는 기능.
  - 트윗 작성하기 기능은 크게 부하를 유발하지 않는다. 여기선 초당 12K 정도의 요청이므로, 하지만 홈타임라인을 보는 기능은 초당 300K 라서 이 부분을 해결해야헀다. 
  - 처음 홈타임라인 기능은 SQL JOIN 을 이용해서 구현했다. 
    - 내가 팔로우하고 있는 사람 중 트윗을 작성한 사람을 찾아서 시간대별로 정렬하는 것.
    - 근데 이렇게 하면 너무 질의 부하가 심했다. 
  - 그래서 트윗을 작성하는 시점에 팔로워들의 홈 타임라인 캐시에 트윗을 넣어주도록 했다.
    - 이렇게 해서 쓰기 시점의 부하를 올려서 해결했는데 이 방식의 문제점은 influencer 같은 경우엔 쓰기 비율이 너무 많다는 것. 
    - 즉 팔로워수가 3천만명이면 그떄 3천만건의 부하가 생기는 것. 
    - 그래서 결국 나중에는 하이브리드식으로 감. 
    - 팔로워수가 적으면 이 방법으로 많으면 기존 방법대로 찾는 식으로 섞어서 진행했다. 

### 성능 기술하기

- 시스템 부하를 기술하면 이제는 부하를 올렸을 때 어떤 일이 일어나는지 조사하는게 가능하다.
  - 시스템 자원은 그대로, 부하 매개변수를 올리면 어떻게 될까. 
  - 부하 매개변수를 증가시켰을 때 성능이 기존과 그대로 유지될려면 자원을 얼마나 투입해야할까, 아니면 어떻게 대처해야할까.
- 부하를 받고도 최소 기존 성능을 유지할 수 있어야하므로 이런 성능을 알기 위해선 성능 지표를 알아야한다.
  - 기본적으로 처리량과 응답 지연시간이 있다. 
  - 온라인 시스템에서 중요한 건 응답 지연시간이다. 
    - 아마존 기준으로 100ms 만 늦어져도 판매량이 1% 줄어들고 1초가 느려지면 고객 만족도는 16% 느려진다는 보고를 했다. 
  - 지연시간과 응답시간은 야간 차이가 있다.
    - 응답시간은 클라이언트 기준으로 측정하는 것. 지연시간은 요청이 처리되는 시간을 말함.
- 일반저으로 응답시간은 매번 다를 수 있다.
  - TCP 재전송, 네트워크 대역폭, Context switching, GC, Page Fault 등이 있기 때문에.
- 응답시간을 기술할려면 산술 평균 보다는 median 값을 기반으로 평가를 내리는게 낫다. 
  - 보통의 사용자들이 받는 응답시간은 p50 (50% 에 있는 사용자 기준으로 설명.)
  - 95분위, 99분위, 99.9 분위 이렇게 평가하기도 한다. **(99.99 분위는 너무나 어려운 영역이라서 하지 않는듯. 아마존은 99.9 분위를 기반으로 평간한다.)**
    - 주로 서비슷 수준의 협약서는 이렇다. 응답 시간 중앙값이 200ms 이어야하고 99분위에서는 1초 미만이어야 한다.

- **응답 시간에 영향을 미치는 주요 요소로는 큐 대기 지연 (queueing delay) 가 있다.** 
  - 큐 대기 지연은 앞에 들어온 하나의 오래 걸리는 연산 떄문에 이후 응답도 같이 느려지는 요인이다.
  - **이런 현상을 head-of-line blocking 이라고 부르기도한다.** 
  - **느린 백엔드 호출 때문에 최종 사용자의 응답도 결국 느려지는 현상을 꼬리 지연 증폭 (tail latency amplification) 이라고도 한다.** 
  - 이를 반영해서 실제 테스트도 해봐야함. 테스트할 때 응답을 받고 보내는거랑 계속해서 응답을 보내는거랑은 응답 지연시간이 달라질 것. 
  - **즉 응답이 느리게 나오는 쿼리 (슬로우 쿼리는 꼭 해결해야할 주제네.)**

### 부하대응 접근 방식 

- 지수적으로 증가하는 트래픽에 대해서는 아키텍처에 대해 재검토가 필요할 수 있다.
- 일반적으로 말하는 확장성은 스케일 아웃과 스케일 업이다.
  - 좋은 장비 하나를 쓰는 것보다 적젏한 장비 몇 대를 쓰는게 비용 효율적이다.
  - 스케일 아웃하기 위해서는 stateless 해야한다.
- 일부 시스템을 탄력성 (elastic) 하게 만들 수도 있다.
  - 자동으로 부하를 감지해서 서버를 더 투입하게 하는 것. 
  - 수동보다는 고려해야할 사항과 이슈가 더 많을 수 있다.
- 그리고 알아둬야 할 사실이 있는데 범용적이고 모든 상황에 맞는 (one-size-fits-all) 아키텍처는 없다. 
- **아키텍처를 결정하는 요소는 부하 매개변수 이다.**
  - 예로 크기가 1KB 와 초당 100,000 건이 들어오는 시스템과 2GB 데이터가 분당 3 건이 들어오는 시스템이 요구하는 아키텍처는 다르다.
  - **여기서 말하는 부하 매개변수는 읽기 쓰기 비율, 데이터 양, 데이터 사이즈, 데이터 복잡도, 응답시간 요구사항, 데이터 접근 패턴등이 있다.**
  - 이런 부하 매개변수를 잘못 잡고 예측하면 아키텍처가 이상해진다. 그래서 스타트업 같은 경우는 미래를 보고 하기보다는 결과를 보고 대응하는게 더 낫다. 

## 유지보수성 

- 소프트웨어 업계에서 레거시 플랫폼을 유지보수 하는 일을 좋아하는 사람은 별로 없다. 
- 그리고 레거시 시스템은 각자마다 불편한 점이 있어서 일반적으로 다루는 법칙은 없다.
- 다만 레거시 시스템을 만들지 않도록, 사람들이 불편해하지 않도록 설계하는 방법을 알아야한다. 다음 그 3가지 요소를 말한다.
  - 운용성 (operability)
    - 운영팀이 시스템을 원활하게 운영할 수 있도록 해줘야한다. 
    - **여기서 말하는 운영팀은 개발자도 포함이다. 운영만 하는 사람을 말하는게 아님**
  - 단순성 (simplicity)
    - 시스템이 복잡하면 안된다. 새로운 엔지니어가 이해할 수 있어야한다. 사용자 인터페이스의 단순성과는 다르다.
    - **이 단순성이 어렵다. 때로는 성능상의 이슈, 문제를 해결하기 위해서 복잡성을 추가해야하는 경우가 있을 수 있다. 이 경우 그 기능을 쉽게 빼고 추가할 수 있도록 하는게 맞지 않을까. 아 이건 발전성이네.**
    - **여기서는 보가 단순한 해결책을 찾도록 하는 방법을 찾아야 한다는 뜻같다.**
  - 발전성 (evolvability)
    - 시스템을 쉽게 변경할 수 있도록 해라.

### 운용성: 운영을 편리하게 해줘야함. 

- 좋은 운영은 나쁜 소프트웨어를 커버해줄 수 있다.
- 여기서 말하는 좋은 운영팀은 다음과 같다. 
  - **(MSA 환경에서 개발팀은 운영도 잘해야한다.)** 
  - 시스템의 상태를 모니터링하고 좋지 않다면 롤백
  - 시스템 장애, 성능 저하 등의 원인을 추적하는게 가능 
  - 보안 패치를 통해 소프트웨어 플랫폼을 최신 상태로 유지 
  - 다른 시스템이 서로 어떻게 영향을 주는 지 확인해 문제가 생기기 전에 차단
  - 미래에 발생 가능한 문제를 예측해서 미리 해결 
  - 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련.  
  - 개인 인사 이후에도 시스템에 대한 조직의 지식을 보존할 수 있다.
  - 동일하게 반복되는 테스크를 자동화한다. 

### 단순성: 복잡성 관리

- 복잡도는 다양한 증상이 있다.
  - 모듈 간 강한 결합
  - 상태 공간의 급증
  - 복잡한 의존성  
  - 일관성 없는 명명
  - 성능문제 해결을 위한 해킹
- **시스템이 복잡하다면 그 만큼 생산성이 떨어진다.**
- **시스템을 단순하게 만든다는 게 기능을 줄인다는 뜻은 아니다. 우발적 복잡도 (accidental complexity) 를 줄인다는 뜻이가.**
  - 우발적 복잡도는 문제를 해결하는 과정에서 의도하지 않았던 결과를 내는 걸 말한다.
    - **다른 추가적인 문제를 만들지 않도록 하는 걸 말하는거네.**
  - **유저가 30 개의 기능이 필요하다고 하면 그 기능을 다 제공해줘야한다. 축소할 수 없는 복잡성도 있다. 이걸 essential complexity 라고한다.**
  - **우발적 복잡도를 해결하기 위한 건 좋은 추상화다. 깔끔하고 직관적인 기능을 제공해주는 것.**
    - 여기서 말하는 좋은 추상화는 SQL 문과 프로그래밍 언어다. 각각 DB 에서 데이터를 가지고 오는 부분과 기계어를 잘 쓰는 부분을 추상화 한 것이므로.

### 발전성: 변화를 쉽게 만들기 

- 시스테의 요구사항은 늘 변하기 쉬우므로 그것에 대응할 수 있어야 한다. 그래서 발전성이 중요함.
- 주로 이런 발전성을 위해서 애자일 커뮤니티에서는 TDD 와 리팩터링을 이야기한다. 근데 이건 동일 어플리케이션 내의 소스코드에만 한정됨.
- 이 객에서는 대규모 데이터 시스템에서 요구사항에 대해 민첩하게 변하는 방법에 대해서 다룸.
  - **이를 위한건 데이터 시스템간의 간단한 결합이어야한다. 간단할수록 수정하기 쉽다.**
  - **그리고 데이터 시스템의 각 특성에 대해서 잘 알아야겠다.**
  
